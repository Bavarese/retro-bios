;---INT 15-----------------------------------------------14-02-89-------------- 
; CASSETTE I/O 
;       (AH) = 0 ВКЛЮЧИТЬ ДВИГАТЕЛЬ (в данной версии 0 и 1 ф-ции 
;       (AH) = 1 ВЫКЛЮЧИТЬ ДВИГАТЕЛЬ   отсутствуют) 
;       (AH) = 2 ЧИТ. 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ С КАССЕТЫ 
;               (ES,BX) = АДРЕС БУФЕРА ДАННЫХ 
;               (CX) = КОЛИЧЕСТВО БАЙТ ДЛЯ ЧТЕНИЯ 
;               НА ВЫХОДЕ: 
;               (ES,BX) = АДРЕС ПОСЛЕДНЕГО СЧИТ. БАЙТА + 1 
;               (DX) = КОЛИЧЕСТВО СЧИТАННЫХ БАЙТ 
;               (CY) = 0 ЕСЛИ НЕТ ОШИБОК ПРИ ЧТЕНИИ 
;                    = 1 ОБНАРУЖЕНА ОШИБКА ЧТЕНИЯ 
;               (AH) = ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ, ЕСЛИ (CY)=1 
;                       =01 ОШИБКА CRC КОНТРОЛЯ 
;                       =02 ПОТЕРЯ ДАННЫХ 
;                       =04 ТАЙМАУТ ПРИ ПОИСКЕ ФАЙЛА 
;       (AH) = 3 ПИСАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКА НА КАССЕТУ 
;               (ES,BX) = АДРЕС ЬУФЕРА ДАННЫХ 
;               (CX) = КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ 
;               НА ВЫХОДЕ: 
;               (EX,BX) = АДРЕС ПОСЛЕДНЕГО ЗАПИСАННОГО БАЙТА + 1 
;               (CX) = 0 
;       (AH) = 4 ЧТЕНИЕ ФАЙЛА С КАССЕТЫ 
;              DS:[BX] - АДРЕС СИМВОЛЬНОЙ СТРОКИ, СОДЕРЖАЩЕЙ ИМЯ ФАЙЛА 
;              (ES) - АДРЕС БУФЕРА ДАННЫХ 
;              НА ВЫХОДЕ: 
;              (AH) - ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ, ЕСЛИ (CY) = 1 
;                       =01 ОШИБКА CRC КОНТРОЛЯ 
;                       =02 ПОТЕРЯ ДАННЫХ 
;                       =04 ТАЙМАУТ ПРИ ПОИСКЕ ФАЙЛА 
;       (AH) = 5 ЗАПИСЬ ФАЙЛА НА КАССЕТУ 
;              DS:[BX] - АДРЕС СИМВОЛЬНОЙ СТРОКИ, СОДЕРЖАЩЕЙ ИМЯ ФАЙЛА 
;              (ES) - АДРЕС БУФЕРА ДАННЫХ 
;              НА ВЫХОДЕ: 
;              (CY) = 1 - ОШИБКА ЧТЕНИЯ 
;       (AH) = ДРУГОЕ ЗНАЧЕНИЕ - (CY)=1 - НЕСУЩЕСТВУЮЩАЯ ОПЕРАЦИЯ, 
;              ВОЗВРАЩАЕТ (AH) = 80 - ПРИЗНАК НЕСУЩЕСТВУЮЩЕЙ ОПЕРАЦИИ. 
;--------------------------------------------------------------------------- 
; 
CASSETTE_IO     PROC        FAR 
        CLI                     ;ЗАПРЕТИТЬ ПРЕРЫВАНИЯ 
        PUSH    DS 
        PUSH    AX 
	MOV	AX,DATA 
	MOV	DS,AX 
        POP     AX 
        CALL    W1              ;ВЫЗВАТЬ ДИСПЕТЧЕР ФУНКЦИЙ 
        POP     DS 
        STI                     ;РАЗРЕШИТЬ ПРЕРЫВАНИЯ 
        RET     2               ;ВОЗВРАТ 
CASSETTE_IO     ENDP 
W1      PROC NEAR 
;-----------------------------------------------------------14-02-89-------- 
; ЦЕЛЬ: 
;  ВЫЗОВ ФУНКЦИИ СОГЛАСНО СОДЕРЖИМОМУ РЕГИСТРА AH 
; 
;  AH           ФУНКЦИЯ 
;----------------------------------------------------------------------------- 
;  0            ВКЛ. ДВИГАТЕЛЬ 
;  1            ВЫКЛ. ДВИГАТЕЛЬ 
;  2            ЧТЕНИЕ БЛОКА 
;  3            ЗАПИСЬ БЛОКА 
;  4            ЧТЕНИЕ ФАЙЛА 
;  5            ЗАПИСЬ ФАЙЛА 
;------------------------------------------------------------------------------ 
 
        OR      AH,AH 
        JNZ     WK1 
        RET 
WK1:    DEC     AH 
        JNZ     WK2 
        RET 
WK2:    DEC     AH                      ;ЧТЕНИЕ? 
        JZ      READ_BLOCK              ;ДА 
        DEC     AH                      ;ЗАПИСЬ? 
        JNZ     W2                      ;НЕТ 
        JMP     WRITE_BLOCK             ;ДА, ЗАПИСЬ 
 
W2: 
        DEC     AH 
        JNZ     W201 
        JMP     FILE_READ               ;ЧТЕНИЕ ФАЙЛА 
W201:   DEC     AH 
        JNZ     W202 
        JMP     FILE_WRITE              ;ЗАПИСЬ ФАЙЛА 
W202: 
                                        ;НЕСУЩЕСТВУЮЩАЯ ФУНКЦИЯ 
        MOV     AH,080H                 ;УСТАНОВИТЬ КОД ВОЗВРАТА 
        STC                             ;УСТАНОВИТЬ ФЛАГ ОШИБКИ 
        RET 
W1      ENDP 
 
READ_BLOCK      PROC    NEAR 
;----------------------------------------------------------------------------- 
; ЦЕЛЬ: 
;   ЧИТАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ С КАССЕТЫ 
; 
; ВХОДНЫЕ ПАРАМЕТРЫ: 
;   ES СЕГМЕНТ БУФЕРА ДЛЯ ПРИЕМА ДАННЫХ 
;   BX УКАЗАТЕЛЬ НАЧАЛА БУФЕРА 
;   CX УКАЗЫВАЕТ КОЛИЧЕСТВО БАЙТ КОТОРЫЕ НЕОБХОДИМО ПРОЧЕСТЬ 
; ВЫХОДНЫЕ ПАРАМЕТРЫ: 
;   BX УКАЗЫВАЕТ АДРЕС БАЙТА СЛЕДУЮЩЕГО ЗА ПОСЛЕДНИМ СЧИТАННЫМ 
;   CX ВЫЧИТАЮЩИЙ СЧЕТИК СЧИТЫВАЕМЫХ БАЙТ 
;   DX СЧЕТЧИК ПРОЧИТАННЫХ БАЙТ 
; 
; ФЛАГ ПЕРЕНОСА РАВЕН НУЛЮ, ЕСЛИ НЕТ ОШИБОК 
; И УСТАНАВЛИВАЕТСЯ ПРИ ОБНАРУЖЕНИИ ОШИБКИ 
;---------------------------------------------------------------------------- 
        PUSH    BX                      ;СОХРАНИТЬ BX 
        PUSH    CX                      ;СОХРАНИТЬ CX 
        PUSH    SI                      ;СОХРАНИТЬ SI 
        MOV     SI,7                    ;ЧИСЛО ПОПЫТОК ПОИСКА ЗАГОЛОВКА 
W4:                                     ;ПОИСК ЗАГОЛОВКА 
        IN      AL,PORT_C               ;СЧИТАТЬ ПОРТ ОБМЕНА С КАССЕТН. 
        AND     AL,010H ;ВЫДЕЛИТЬ СИГНАЛЬНЫЙ РАЗРЯД 
        MOV     LAST_VAL,AL             ;СОХРАНИТЬ ЗНАЧЕНИЕ УРОВНЯ СИГНАЛА 
        MOV     DX,16250                ;ЧИСЛО ЦИКЛОВ ДЛЯ ОЖИДАНИЯ ПЕРЕПАДА 
W5:                                     ;УРОВНЯ СИГНАЛА 
        CALL    BREAK_TEST              ;ПРЕРВАТЬ СЧИТЫВАНИЕ? 
        JNZ     W6                      ;НЕТ 
        JMP     W17                     ;ПРЕРВАТЬ ЧТЕНИЕ 
 
W6:     DEC     DX 
        JNZ     W7                      ;ПЕРЕХОД, ЕСЛИ НАЧАЛО ЗАГОЛОВКА 
        JMP     W17                     ;ПЕРЕХОД, ЕСЛИ ЗАГОЛОВОК НЕ НАЙДЕН 
 
W7:     CALL    READ_HALF_BIT           ;ИГНОРИРОВАТЬ ПЕРВЫЙ ИМПУЛЬС 
        JCXZ    W5                      ;ПЕРЕЙТИ ЕСЛИ НЕ БЫЛО ПЕРЕПАДА СИГН. 
        IN      AL,021H ;ПРОЧИТАТЬ РЕГ. МАСКИ ПРЕРЫВАНИЙ 
        OR      AL,1                    ;ЗАПРЕТИТЬ ПРЕРЫВАНИЯ ОТ ТАЙМЕРА 
        OUT     021H,AL 
; 
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ П/ПЕРИОДА 
        JCXZ    W4                      ;ТАЙМАУТ 
        MOV     DX,BX                   ;СОХРАНИТЬ ПОЛУЧ. ДЛИТ. 
	CALL	READ_HALF_BIT		;ПОЛУЧИТЬ ДЛИТ. 2-ГО П/ПЕРИОДА 
	JCXZ	W4			;ТАЙМАУТ 
	ADD	BX,DX			;ПОЛУЧИТЬ ДЛИТ. ПЕРИОДА 
 
;  -----------   ЦИКЛ ДЛЯ РАСПОЗНАВАНИЯ ЗАГОЛОВКА 
 
	MOV	CX,100H	 ;СЧЕТЧИК БАЙТОВ ДЛЯ ИДЕНТИФИКАЦИИ 
W8: 
	CALL	BREAK_TEST		;ПРЕРВАТЬ? 
        JNZ     W117                    ;НЕТ 
        JMP     W17                     ;ДА 
W117:   XCHG    DX,BX                   ;СОХРАНИТЬ ДЛИТ. ПРЕДЫДУЩ. ПЕРИОДА 
        PUSH    CX 
; ----------------------------  ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ НОВОГО ПЕРИОДА 
	CALL	READ_HALF_BIT		;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ П/ПЕРИОДА 
        OR      CX,CX 
        POP     CX 
        JZ      W4 
        PUSH    CX 
	PUSH	BX			;СОХРАНИТЬ ПОЛУЧ.ДЛИТ. П/ПЕРИОДА 
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ НОВУЮ ДЛИТ. 
        OR      CX,CX 
	POP	AX			;В AX ВОССТАНОВИТЬ ПРЕДЫДУЩ. ДЛИТ. 
        POP     CX 
        JZ      W4 
	ADD	BX,AX			;BX <--- ДЛИТ. НОВОГО ПЕРИОДА 
	SUB	DX,BX			;СРАВНИТЬ ДЛИТ. НОВОГО И ПРЕДЫДУЩ.ПЕР. 
	JNC	W801			;ЕСЛИ РАЗНИЦА ОТРИЦАТЕЛЬНА, 
	NEG	DX			;ПОЛУЧИТЬ АБСОЛЮТНОЕ ЗНАЧЕНИЕ 
W801:	CMP	DX,0C0H ;ПРОВЕРИТЬ НА ДОПУСТИМУЮ РАЗНИЦУ 
					;ПРЕДЫДУЩИЙ И НОВЫЙ ПЕРИОД 
	JNC	W4			;РАЗНИЦА БОЛЬШЕ ДОПУСТИМОЙ 
 
	LOOP	W8			;ПОВТОРИТЬ, ЕСЛИ ПРОАНАЛИЗИРВАНО 
					;МЕНЬШЕ 256 (100H) ПЕРИОДОВ 
 
;--- ЕСЛИ НАЧАЛО ЗАГОЛОВКА ОПОЗНАНО, ВЫЧИСЛИТЬ СРЕДНЮЮ ДЛИТЕЛЬНОСТЬ 
;    ПЕРИОДА БИТОВ "1" И МИНИМАЛЬНО-ДОПУСТИМУЮ ДЛИТ. "1" 
 
        XCHG    DX,BX 
        MOV     CX,0FFH ;УСТАНОВИТЬ СЧЕТЧИК 
        XOR     AX,AX                   ;ОБНУЛИТЬ СУММАТОР ОТКЛОНЕНИЙ 
W88:    PUSH    CX                      ;СОХРАНИТЬ СЧЕТЧИК 
        PUSH    AX                      ;СОХРАНИТЬ СУММУ ОТКЛОНЕНИЙ 
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА 
        PUSH    BX                      ;СОХРАНИТЬ ПОЛУЧ. ДЛИТ. 
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТ. 2-ГО ПОЛУПЕРИОДА 
        POP     AX                      ;ВОССТАНОВИТЬ ПРЕДЫДУЩУЮ ДЛИТ. 
        ADD     BX,AX                   ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ ПЕРИОДА 
        POP     AX                      ;ВОССТАНОВИТЬ СУММУ ОТКЛОНЕНИЙ 
        SUB     BX,DX                   ;ПОЛУЧИТЬ НОВОЕ ОТКЛОНЕНИЕ 
        ADD     AX,BX                   ;ПРИБАВИТЬ К СУММЕ 
        POP     CX                      ;ВОССТАНОВИТЬ СЧЕТЧИК 
        LOOP    W88 
; 
        MOV     CL,8 
        SAR     AX,CL                   ;ПОЛУЧИТЬ СРЕДНЕЕ ОТКЛОНЕНИЕ 
        ADD     DX,AX                   ;DX <--- СРЕДНЕЕ ЗНАЧ. ПЕРИОДА "1" P1 
        MOV     BX,DX 
        SAR     BX,1                    ;BX <--- P1/2 
        MOV     DX,BX 
        SAR     BX,1                    ;BX <--- P1/4 
        ADD     DX,BX                   ;DX <--- 0.75*P1 - MIN ДОП. ЗНАЧ. ПЕР 
        MOV     LOWLIM,DX               ;СОХР. MIN ДОП. ЗНАЧ. ПЕРИОДА "1" 
        MOV     DX,BX 
        SAR     BX,1                    ;BX <--- P1/8 
        ADD     DX,BX                   ;DX <--- 3/8 * P1 - MIN ДОП. ЗНАЧЕНИЕ 
                                        ;ПОЛУПЕРИОДА "1" ДЛЯ ПОИСКА СТАРТ-БИТА 
; 
;                               ПОИСК "0" - СТАРТ-БИТА 
W89: 
        CALL    BREAK_TEST              ;ПРЕРВАТЬ ЧТЕНИЕ 
        JZ      W17                     ;ДА 
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТ. ПОЛУПЕРИОДА СИГНАЛА 
        CMP     DX,BX                   ;"0" ИЛИ "1"? 
        JC      W89                     ;ЕСЛИ "1" - ПОВТОРИТЬ 
; 
;   СТАРТ-БИТ НАЙДЕН. ПРОВЕРКА СИНХРОСИМВОЛА: 
        CALL    READ_HALF_BIT           ;ПРОПУСТИТЬ 2-Й ПОЛУПЕРИОД СТАРТ-БИТА 
        CALL    READ_BYTE               ;ПРОЧИТАТЬ СИНХРОБАЙТ 
        CMP     AL,16H                  ;ПРОВЕРИТЬ СИНХРО-СИМВОЛ 
        JNE     W16                     ;ПЕРЕХОД, ЕСЛИ ПЛОХОЙ ЗАГОЛОВОК 
 
;------ЗАГОЛОВОК ПРОЧИТАН УСПЕШНО. ЧТЕНИЕ БЛОКОВ ДАННЫХ 
        POP     SI                      ;ВОССТАНОВИТЬ РЕГИСТРЫ 
        POP     CX 
        POP     BX 
 
;------------------------------------------------------------------------- 
; ЧИТАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ ДАННЫХ С КАССЕТЫ 
; 
;НА ВХОДЕ: 
; ES - СЕГМЕНТ ДЛЯ БУФЕРА В ПАМЯТИ ДЛЯ ПРИЕМА СЧИТАННЫХ БАЙТ 
; BX - УКАЗАТЕЛЬ АДРЕСА В БУФЕРЕ 
; CX - СОДЕРЖИТ КОЛИЧЕСТВО БАЙТ КОТОРЫЕ НЕОБХОДИМО ПРОЧИТАТЬ 
;НА ВЫХОДЕ: 
; BX - УКАЗЫВАЕТ АДРЕС БАЙА В БУФЕРЕ, СЛЕДУЮЩЕГО ЗА ПОСЛЕДНИМ ПРЧИТАННЫМ 
; CX - ВЫЧИТАЮЩИЙ СЕТЧИК СЧИТЫВАЕМЫХ БАЙТ 
; DX - СОДЕРЖИТ КОЛИЧЕСТВО ПРОЧИТАННЫХ БАЙТ 
;--------------------------------------------------------------------------- 
        PUSH    CX                      ;СОРАНИТЬ СЧЕТЧИК БАЙТ 
W10:                                    ;ТОЧКА ВХОДА ДЛЯ ВОЗВРАТА 
                                        ;ПО ПРОЧТЕНИЮ 256-БАЙТНОГО БЛОКА 
        MOV     CRC_REG,0FFFFH          ;ИНИЦИАЛИЗИРОВАТЬ CRC-РЕГИСТР 
        MOV     DX,256                  ;DX <--- РАЗМЕР БЛОКА ДАННЫХ 
W11:                                    ;ЧИТАТЬ БЛОК 
        CALL    BREAK_TEST              ;ПРЕРВАТЬ ЧТЕНИЕ? 
        JZ      W13                     ;ДА 
        CALL    READ_BYTE               ;СЧИТАТЬ БАЙТ 
        JC      W13                     ;ЕСЛИ ОШИБКА - CY=1 
        JCXZ    W12                     ;ЕСЛИ ПРОЧИТАНЫ ВСЕ БАЙТЫ (CX), 
                                        ;ДОЧИТАТЬ БЛОК, НО В БУФЕРЕ 
                                        ;НЕ СОХРАНЯТЬ 
        MOV     ES:[BX],AL              ;СОХРАНИТЬ БАЙТ В БУФЕРЕ 
        INC     BX                      ;УВЕЛИЧИТЬ АДРЕС БУФЕРА 
        DEC     CX                      ;УМЕНЬШИТЬ СЧЕТЧИК БАЙТ 
W12:                    ;ЗАВЕРШЕНИЕ ЦИКЛА ЧТЕНИЯ 256-БАЙТНОГО БЛОКА ДАННЫХ 
        DEC     DX                      ;УМЕНЬШИТЬ СЧЕТЧИК БАЙТ В БЛОКЕ 
        JG      W11                     ;ВОЗВРАТ НА ЧТЕНИЕ, ЕСЛИ < 256 
        CALL    READ_BYTE               ;ТЕПЕРЬ ЧИТАЕМ ДВА БАЙТА CRC 
        CALL    READ_BYTE 
        SUB     AH,AH                   ;ОБНУЛЯЕМ AH 
        CMP     CRC_REG,1D0FH           ;CRC ПРАВИЛЬНО? 
        JNE     W14                     ;ПЕРЕЙТИ, ЕСЛИ ОШИБКА 
        JCXZ    W15                     ;ЕСЛИ СЧЕТЧИК БАЙТ=0, Т.Е. 
                                        ;ПРОЧИТАНЫ ВСЕ ДАННЫЕ, 
                                        ;ЗАВЕРШИТЬ ЧТЕНИЕ 
        JMP     W10                     ;ЕСЛИ НЕТ - ЧИТАТЬ СЛЕДУЮЩИЙ БЛОК 
                                ;ОБРАБОТКА ОШИБОК ЧТЕНИЯ 
W13:                                    ;ПОТЕРЯНЫ ДАННЫЕ 
        MOV     AH,01H                  ;УСТАНОВИТЬ КОД ВОЗВРАТА AH=02 - 
                                        ;"ПОТЕРЯНЫ ДАННЫЕ" 
W14:                                    ;ОШИБКА CRC-КОНТРОЛЯ 
        INC     AH                      ;УСТАНОВИТЬ КОД ВОЗВРАТА AH=01 - 
                                        ;"ОШИБКА CRC-КОНТРОЛЯ" 
W15:                                    ;ЗАВЕРШЕНИЕ ЧТЕНИЯ 
        POP     DX                      ;ВЫЧИСЛИТЬ ЧИСЛО РЕАЛЬНО 
        SUB     DX,CX                   ;ПРОЧИТАННЫХ БАЙТ 
                                        ;ДЛЯ ВОЗВРАТА В РЕГ. DX 
        PUSH    AX                      ;СОХРАНИТЬ AX (КОД ВОЗВРАТА) 
        TEST    AH,03H                  ;ЕСТЬ ОШИБКИ? 
        JNZ     W18                     ;ВЫХОД ПО ОШИБКЕ 
        CALL    READ_BYTE               ;ПРОЧИТАТЬ КОНЕЦ 
        JMP     SHORT W18               ;ВЫПОЛНИТЬ ВЫКЛЮЧЕНИЕ ДВИГАТЕЛЯ 
W16:                                    ;ПЛОХОЙ ЗАГОЛОВОК 
        DEC     SI                      ;ПРОВЕРИТЬ ЧИСЛО ПОПЫТОК ПОВТОРА 
                                        ;РАСПОЗНАТЬ ЗАГОЛОВОК 
        JZ      W17                     ;ЧИСЛО ПОПЫТОК БОЛЬШЕ ДОПУСТИМОГО 
        JMP     W4                      ;ПОПЫТАТЬСЯ ЕЩЕ РАЗ 
W17:                                    ;НЕ НАЙДЕНЫ ДАННЫЕ 
;-------НЕ НАЙДЕНЫ ДАННЫЕ НА КАССЕТЕ,Т.Е. ТАЙМАУТ ПРИ ЧТЕНИИ 
 
        POP     SI                      ;ВОССТАНОВИТЬ РЕГИСТРЫ 
        POP     CX 
        POP     BX 
        SUB     DX,DX                   ;НУЛЬ БАЙТОВ ПРОЧИТАНО 
        MOV     AH,04H                  ;ОШИБКА "ТАЙМАУТ ПРИ ЧТЕНИИ" 
        PUSH    AX 
W18: 
        IN      AL,021H         ;ПЕРЕРАЗРЕШИТЬ ПРЕРЫВАНИЯ 
        AND     AL,0FFH-1 
        OUT     021H,AL 
        POP     AX                      ;ВОССТАНОВИТЬ КОД ВОЗВРАТА 
        CMP     AH,01H                  ;УСТАНОВИТЬ CY=1 ПРИ ОШИБКЕ (AH>0) 
        CMC 
        RET                             ;ЗАКОНЧИТЬ 
READ_BLOCK      ENDP 
;--------------------------------------------------------------------------- 
READ_BYTE       PROC NEAR 
; ЦЕЛЬ: 
;  ПРОЧИТАТЬ БАЙТ С КАССЕТЫ 
;  НА ВЫХОДЕ РЕГИСТР AL СОДЕРЖИТ ПРОИТАННЫЙ БАЙТ ДАННЫХ 
;--------------------------------------------------------------------------- 
        PUSH    BX                      ;СОХРАНИТЬ РЕГИСТРЫ BX,CX 
        PUSH    CX 
        MOV     CL,8H                   ;УСТАНОВИТЬ СЧЕТЧИК БИТ РАВНЫМ 8 
W19:                                    ;ЧИТАТЬ БАЙТ 
        PUSH    CX                      ;СОХРАНИТЬ СЧЕТЧИК БИТ 
 
;---------------------------------------------------------------------------- 
;  ЧИТАТЬ БИТ ДАННЫХ С КАССЕТЫ 
;---------------------------------------------------------------------------- 
        CALL    READ_HALF_BIT           ;ПРОЧИТАТЬ ОДИН ПОЛУПЕРИОД 
        JCXZ    W21                     ;ЕСЛИ CX=0 - ИМПУЛЬС-ТАЙМАУТ 
                                        ;НЕТ ЗАДЕГО ФРОНТА ИМПУЛЬСА 
        PUSH    BX                      ;СОХРАНИТЬ ДЛИТЕЛЬНОСТЬ 
                                        ;ПОЛУПЕРИОДА (IN BX) 
        CALL    READ_HALF_BIT           ;ПРОЧИТАТЬ ВТОРОЙ ПОЛУПЕРИОД 
        POP     AX                      ;ВОССТАНОВИТЬ ДЛИТ. ПРЕДЫДУЩ. ИМП. 
        JCXZ    W21                     ;ЕСЛИ CX=0 - ИМПУЛЬС-ТАЙМАУТ 
        ADD     BX,AX                   ;ВЫЧИСЛИТЬ ДЛИНУ ПЕРИОДА 
        CMP     BX,LOWLIM               ;ПРОВЕРИТЬ "0" ИЛИ "1" 
        CMC                             ;CY=1, ЕСЛИ ЕДИНИЧНЫЙ БИТ 
        LAHF                            ;СОХРАНИТЬ ФЛАГ ПЕРЕНОСА В AH 
        POP     CX                      ;ВОССТАНОВИТЬ СЧЕТЧИК БИТ 
                                        ;ДЛЯ СПРАВКИ: 
                                        ;СТАРШИЙ БИТ ЧИТАЕТСЯ ПЕРВЫМ 
                                        ;РЕГ. CH СДВИГАЕТСЯ ВЛЕВО И 
                                        ;ПЕРЕНОС ЗАНОСИТСЯ В МЛАДШИЙ БИТ 
                                        ;РЕГИСТРА CH. 
                                        ;ПОСЛЕ СЧИТЫВАНИЯ ВСЕХ 8 БИТ 
                                        ;СТАРШИЙ БИТ СЧИТЫВАЕМОГО БАЙТА 
                                        ;ОКАЖЕТСЯ В СТАРШЕМ БИТЕ РЕГ. CH 
        RCL     CH,1                    ;СДВИГАЕМ РЕГ. CH ВЛЕВО ДЛЯ ЗАНЕСЕНИЯ 
                                        ;ПЕРЕНОСА В МЛАДШИЙ БИТ РЕГ. CH 
        SAHF                            ;ВОССТАНАВЛИВАЕМ CY ДЛЯ ВЫЧИСЛЕНИЯ CRC 
        CALL    CRC_GEN         ;ГЕНЕРИРУЕМ CRC ДЛЯ СЧИТАННОГО БИТА 
        DEC     CL                      ;УМЕНЬШАЕМ СЧЕТЧИК БИТ 
                                        ;ПОВТОРЯЕМ ЧТЕНИЕ БИТА ПОКА НЕ ПРОЧИ- 
        JNZ     W19                     ;ТАЕМ ВСЕ 8. 
        MOV     AL,CH                   ;AL <--- ПРОЧИТАННЫЙ БАЙТ 
        CLC 
W20:                                    ;ЗАВЕРШИТЬ ЧТЕНИЕ БАЙТА 
        POP     CX                      ;ВОССТАНОВИТЬ РЕГ. CX,BX 
        POP     BX 
        RET                             ;ЗАКОНЧИТЬ 
W21:                                    ;ПОТЕРЯ ДАННЫХ 
        POP     CX                      ;ВОССТАНОВИТЬ CX 
        STC                             ;УСТАНОВИТЬ ФЛАГ ОШИБКИ 
        JMP     W20                     ;ЗАВЕРШИТЬ ЧТЕНИЕ 
READ_BYTE       ENDP 
 
;-------------------------------------------------------------------------- 
WRITE_BLOCK     PROC    NEAR 
; 
; ЗАПИСЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ НА КАССЕТУ. 
;       В ПОСЛЕДНЕМ БЛОКЕ ДАННЫЕ ДОПОЛНЯЮТСЯ ПОСЛЕДНИМ БАЙТОМ ДО ДЛИНЫ 256. 
; 
; ВХОДНЫЕ ПАРАМЕТРЫ: 
;  BX - УКАЗАТЕЛЬ АДРЕСА БУФЕРА ДАННЫХ 
;  CX - КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ 
; 
; НА ВЫХОДЕ: 
;  BX УКАЗЫВАЕТ АДРЕС БАЙТА, КОТОРЫЙ СЛЕДУЕТ ЗА ПОСЛЕДНИМ ЗАПИСАННЫМ 
;  CX РАВЕН НУЛЮ 
;--------------------------------------------------------------------------- 
        PUSH    BX 
        PUSH    CX 
        IN      AL,PORT_B               ;ВЫКЛЮЧИТЬ ГРОМКОГОВОРИТЕЛЬ 
        AND     AL,NOT 02H 
        OR      AL,01H                  ;РАЗРЕШИТЬ СЧЕТ 2 КАНАЛА ТАЙМЕРА 
        OUT     PORT_B,AL 
        MOV     AL,0B6H          ;КАНАЛ 2 ТАЙМЕРА В РЕЖИМ 3 
        OUT     TIM_CTL,AL 
        MOV     AX,1184  ;КОЭФ. ДЕЛЕНИЯ ДЛЯ ЧАСТОТЫ "1" 
        CALL    W31                     ;ЗАГРУЗИТЬ ТАЙМЕР 
        MOV     CX,0800H                ;СЧЕТЧИК ВИТОВ ДЛЯ ЗАГОЛОВКА 
W23:                                    ;ЗАПИСАТЬ ЗАГОЛОВОК 
        STC                             ;ЗАПИСАТЬ БИТ "1" 
        CALL    WRITE_BIT               ; 
        LOOP    W23                     ;ЗАПИСАН ВЕСЬ ЗАГОЛОВОК? 
        CLC                             ;ЗАПИСАТЬ СИНРО-БИТ (0) 
        CALL    WRITE_BIT 
        POP     CX                      ;ВОССТАНОВИТЬ CX,BX 
        POP     BX 
        MOV     AL,16H                  ;ЗАПИСАТЬ СИНХРО-СИМВОЛ 
        CALL    WRITE_BYTE              ; 
 
;------------------------------------------------------------------------- 
; ЗАПИСАТЬ 1 ИЛИ БОЛЬШЕ 256-БИТНЫХ БЛОКОВ НА КАССЕТУ. 
; 
; ВХОДНЫЕ ПАРАМЕТРЫ: 
;  BX - УКАЗАТЕЛЬ АДРЕСА БУФЕРА ДАННЫХ 
;  CX - КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ 
; 
; НА ВЫХОДЕ: 
;  BX УКАЗЫВАЕТ АДРЕС БАЙТА, КОТОРЫЙ СЛЕДУЕТ ЗА ПОСЛЕДНИМ ЗАПИСАННЫМ 
;  CX РАВЕН НУЛЮ 
; 
;--------------------------------------------------------------------------- 
WR_BLOCK: 
        MOV     CRC_REG,0FFFFH          ;ИНИЦИАЛИЗИРОВАТЬ CRC-РЕГИСТР 
        MOV     DX,256                  ;СЧЕТЧИК БАЙТ В БЛОКЕ 
W24:                                    ;WR-BLK 
        MOV     AL,ES:[BX]              ;ПРОЧИТАТЬ БАЙТ ИЗ ПАМЯТИ 
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО НА КАССЕТУ 
        JCXZ    W25                     ;ЕСЛИ CX=0,НЕ ИЗМЕНЯТЬ СЧЕТЧИК ИУКАЗАТ. 
        INC     BX                      ;INC УКАЗАТЕЛЬ АДРЕСА БУФЕРА 
        DEC     CX                      ;DEC СЧЕТЧИК ЗАПИСЫВЕМЫХ БАЙТ 
W25:                                    ;SKIP-ADV 
        DEC     DX                      ;DEC СЧЕТЧИК БАЙТ БЛОКА 
        JG      W24                     ;ЗАПИСАНЫ ВСЕ 256 БАЙТ ДАННОГО БЛОКА? 
 
;----------------------ЗАПИСАТЬ CRC------------------------------------------- 
; ЗАПИСАТЬ ОБРАТНЫЙ КОД CRC-РЕГИСТРА НА КАССЕТУ. 
; ПРИ СЧИТЫВАНИИ БЛОКА ПРОВЕРЯЕТСЯ СООТВЕТСТВИЕ ВЫЧИСЛЕННОГО И СЧИТАННОГО CRC 
; 
; МОДИФИЦИРУЕТ РЕГИСТР AX 
;----------------------------------------------------------------------------- 
        MOV     AX,CRC_REG              ;ЗАПИСАТЬ ОБРАТНЫЙ КОД CRC-РЕГИСТРА 
                                        ;В ВИДЕ ДВУХ БАЙТОВ CRC НА КАССЕТУ 
        NOT     AX                      ;ПОЛУЧИТЬ ОБРАТНЫЙ КОД 
        PUSH    AX                      ;СОХРАНИТЬ ЕГО 
        XCHG    AH,AL                   ;СТАРШИЙ БАЙТ ЗАПИСЫВАЕТСЯ ПЕРВЫМ 
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО 
        POP     AX                      ;ВОССТАНОВИТЬ МЛАДШИЙ БАЙТ 
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО 
        OR      CX,CX                   ;ВСЕ БАЙТЫ ЗАПИСАНЫ? 
        JNZ     WR_BLOCK                ;ЕСЛИ НЕТ ПРОДОЛЖИТЬ 
        PUSH    CX                      ;СОХРАНИТЬ CX 
        MOV     CX,32                   ;ЗАПИСАТЬ КОНЕЦ ФАЙЛА 
W26:                                    ;ЦИКЛ ЗАПИСИ КОНЦА ФАЙЛА 
        STC 
        CALL    WRITE_BIT 
        LOOP    W26                     ;ПИСАТЬ ПОКА ИСЧЕРПАЕТСЯ СЧЕТЧИК 
        POP     CX                      ;ВОССТАНОВИТЬ CX 
	MOV	AL,0B0H		;ВОССТАНОВИТЬ РЕЖИМ ТАЙМЕРА 
        OUT     TIM_CTL,AL 
        MOV     AX,1 
        CALL    W31 
        IN      AL,PORT_B 
        AND     AL,NOT 01H 
        OUT     PORT_B,AL 
        SUB     AX,AX                   ;НЕТ ОШИБОК ЗАПИСИ 
        RET                             ;ЗАКОНЧИТЬ 
WRITE_BLOCK     ENDP 
 
 
                ORG     0FA6EH 
 
